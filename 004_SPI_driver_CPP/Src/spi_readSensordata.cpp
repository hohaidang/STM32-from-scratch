/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "../driver/inc/stm32f4xx.h"
#include "../driver/inc/bme280_driver.h"
#include <vector>

using namespace std;


void InitilizePeripheral(void);
void user_delay_us(u32);
u8 user_spi_read (const u8, u8 *, u32);
u8 user_spi_write(const u8, const u8 *, u32);


// Alternate function 5
SPI_Handler *SPI1_Handler;
GPIO_Handler *PB6;
BMESensor_Handler *bme280;


int main(void)
{
    bme280_settings temp = { 0 };
    InitilizePeripheral();
    if (bme280->get_status() == SENSOR_OK) {
        bme280->setSensorMode(BME280_NORMAL_MODE);

        bme280_settings settings;
        settings.osr_h = 0x07; // x16
        settings.osr_t = 0x07; // x16
        settings.osr_p = 0x07; // x16
        bme280->set_sensor_settings(settings);
        bme280->get_sensor_settings(temp);
        while(1) {
            // get sensor data
            bme280->get_sensor_data();

#ifdef DEBUG_EN
			bme280->print_sensor_data();
#endif
			for (int i = 0; i < 1000000; ++i);
       }
    }
    else {
#ifdef DEBUG_EN
    	cout << "Sensor Init failed. Please check again hardware connection pins" << endl;
#endif
    }


   return 0;
}

void InitilizePeripheral(void) {
    // HSI Clock 16 Mhz
    SPI1_Handler = new SPI_Handler(SPI1,
                                    SPI_DEVICE_MODE_MASTER,
                                    SPI_BUS_CONFIG_FD,
                                    SPI_SCLK_SPEED_DIV32,
                                    SPI_DFF_8BITS,
                                    SPI_CPOL_LOW,
                                    SPI_CPHA_LOW,
                                    SPI_SSM_EN);

    // TODO: design interrupt for SPI connect with sensor
//  SPI1_Handler->SPI_IRQInterruptConfig(IRQ_NO_SPI1, ENABLE);
//  SPI1_Handler->SPI_IRQPriorityConfig(IRQ_NO_SPI1, IRQ_Prio_NO_15);

    PB6 = new GPIO_Handler(GPIOB,
                           GPIO_PIN_NO_6,
                           GPIO_MODE_OUT,
                           GPIO_SPEED_FAST,
                           GPIO_OP_TYPE_PP,
                           GPIO_NO_PUPD);
    PB6->GPIO_WriteToOutputPin(SET);

    bme280 = new BMESensor_Handler(user_spi_read,
                                   user_spi_write,
                                   user_delay_us);
}

void user_delay_us(u32 period)
{
    // TODO: Design system tick in here
    for(int i = 0; i < 25000; ++i) {

    }
}

u8 user_spi_read (const u8 reg_addr, u8 *reg_data, u32 len) {
    vector<u8> txBuffer(len + 1, 0);
    vector<u8> rxBuffer(len + 1, 0);
    txBuffer[0] = reg_addr;

    PB6->GPIO_WriteToOutputPin(RESET);

    SPI1_Handler->SPI_SendAndReceiveData(&txBuffer[0], &rxBuffer[0], len + 1);

    PB6->GPIO_WriteToOutputPin(SET);

    // copy to reg_data
    for(u32 i = 0; i < len; ++i) {
        reg_data[i] = rxBuffer[i + 1];
    }
    return 0;
}

u8 user_spi_write(const u8 reg_addr, const u8 *reg_data, u32 len) {
    vector<u8> txBuffer(len + 1, 0);
    txBuffer[0] = reg_addr;
    for(u32 i = 0; i < len; ++i) {
        txBuffer[i + 1] = reg_data[i];
    }

    PB6->GPIO_WriteToOutputPin(RESET);
    SPI1_Handler->SPI_SendData(&txBuffer[0], len + 1);
    PB6->GPIO_WriteToOutputPin(SET);

    return 0;
}

extern "C" {
    void SPI1_IRQHandler(void) {
        // handle the interrupt
        SPI1_Handler->SPI_IRQHandling();
    }
}
